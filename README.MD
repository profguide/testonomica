# Requirements

- wkhtmltopdf для преобразования html в pdf (для отчётов).

      Mac:
      brew install wkhtmltopdf
    
      Debian:
      apt-get install wkhtmltopdf

# Сервер

    symfony server:start

# Тест

    php bin/phpunit

или

    make tests
    Скрипт очищает базу, выполняет миграции, создаёт фикстуры

## Применение фикстур

    symfony console doctrine:fixtures:load
    APP_ENV=test symfony console doctrine:fixtures:load 

# Миграция

## Создание файлов миграции из моделей

    php bin/console doctrine:migrations:diff

## Применение миграции

    php bin/console doctrine:migrations:migrate
    APP_ENV=test php bin/console doctrine:migrations:migrate

## Откат миграций

    php bin/console doctrine:migrations:migrate prev
    APP_ENV=test php bin/console doctrine:migrations:migrate prev

# Frontend

    yarn watch

    yarn build

## testonomica_api

В директории testonomica_api выполнить:

    yarn link

В директории testonomica выполнить:

    yarn link testonomica_api

# PHPSTORM

Xdebug 3 в консоли работает только с портом 9003. Поэтому в PhpStorm нужно установить порядок портов 9003,9000

# Upgrading a Minor Version

    https://symfony.com/doc/current/setup/upgrade_minor.html#upgrading-other-packages

# Урлы

## Паблик: список тестов, страница теста, страница результата

- /tests/
- /tests/view/{slug}/
- /tests/result/{uuid}/

## Rest API: test

- /tests/api/v1/info/{testId}/
- /tests/api/v1/first/{testId}/
- /tests/api/v1/next/{testId}/
- /tests/api/v1/prev/{testId}/
- /tests/api/v1/save/{testId}/ (сохранить список ответов)
- /tests/api/v1/result/{testId}/?format={format} (format: PDF/HTML)

## Rest API: payment

- /access/has/ (есть доступ по токену?)
- /access/order/ (дай заказ по токену)
- /access/grand/ (дай доступ)

## Партнёр получает токен доступа/оплаты (скрытно)

- /partner/api/token/

## Партнёр получает результаты/ответы (скрытно)

- /partner/api/test/result/{key}/?format={format} (получить результаты) (format: JSON/PDF/HTML)

Повышенный уроверь доступа (ПрофГид):

- /partner/api/test/progress/{key}/ (получить массив ответов)
- /partner/api/test/calculate/{id}/ (получить результаты из переданных ответов)

## Партнёр отправляет пользователя с токеном: он либо попадёт в оплату, либо попадёт в тест.

- /partner/provide/

# Интеграция (текст дополняется при каждом изменении)

Интеграция возможна на платной и бесплатной основе (бесплатные тесты).

В обоих случаях тест грузится через один и тот же виджет.

В обоих случаях загрузка виджета возможна только для зарегистрированного домена.

Отличие платного от бесплатного варианта только в наличии/отсутствии токена в урле.

## Бесплатная интеграция (бесплатный тест)

Бесплатная интеграция - интеграция для предоставления доступа к бесплатным тестам.

```
<script src="https://testonomica/build/widget-v1.js"></script>
<div id="testonomica_app" data-test="TEST_SLUG"></div>
```

## Платная интеграция (платный тест)

Платная интеграция нужна для предоставления доступа к платным тестам.

Вызов виджета отличается добавлением публичного токена {PUBLIC_TOKEN}, который необходимо получить скрытым образом (
будет описано далее).

```
    <script src="https://testonomica/build/widget-v1.js"></script>
    <div id="testonomica_app" data-token="PUBLIC_TOKEN" data-test="TEST_SLUG"></div>
```

{PUBLIC_TOKEN} - одноразовый публичный ключ, скрытно полученный в запросе backend2backend.

### Получение публичного токена {PUBLIC_TOKEN}

Публичный токен выдаётся нами по закрытому запросу (backend), например, curl:

```
    https://testonomica.com/partner/api/token/?token={SECRET_TOKEN}&user={USER_ID}&service=proftest
```

{SECRET_TOKEN} - постоянный токен партнёра, который будет выдан при регистрации (или по личному обращению).

{USER_ID} - id пользователя в системе партнёра.

Ответом будет публичный токен:

    {"token":"cf738dd7-a138-4fa6-b3fd-52eef8ae2a92"}

### Оплата

Возможны два варианта оплаты:

1. Оплата совершается пользователем на нашей стороне;
2. Оплата совершается пользователем на стороне партнёра;

#### 1. Оплата на нашей стороне

Как понять, что пользователь оплатил? Публичный токен - это токен оплаты?

Планирую сделать приём платежей прямо в виджете, если такое возможно в принципе - во всплывающем окне. Например, указать
дополнительно в платном варианте data-payment="auto". В случае с тестометрикой виджета нет, а сразу используется
js-приложение, поэтому приём платежей нужно сделать именно через это приложение, а не через виджет.

## Как устроена нутрянка

### Сценарий: Виджет. Платный тест. Вариант 1

Партнёр скрытно получает токен по адресу /partner/api/token/ с параметрами... При этом будет создан то... /access/has/ -
/access/order/ -

backend партнера запрашивает публичный токен для юзера;

В случае со скилбоксом действует предоплата (или постоплата).

Для этого нужен доппараметр: payment (user|company).

Если user - то всё как обычно - платит пользователь (а-ля тестометрика).

Если company, то смотрим профиль компании:
предоплата или постоплата. Если предоплата, то должен быть лимит, допустим 1000 штук. При наступленнии лимита вежливо
уведомляем. Если постоплата, то лимита нет, но всегда должен быть подсчёт.

ХЗ где и как пока. В обоих случаях (
prepayment и postpaid) нужно вести учёт сколько израсходованно. Где? Мы ведём статистику - сколько раз партнёр
предоставил доступ - сколько учтено, а сколько нет. Каждый запрос токена с уникальным юзером - это факт преобретения
теста, то есть покупки.

- Виджет загружает страницу, где расположен автозагрузчик теста на react (далее App-js)
- App-js запрашивает данные по тесту у сервера, передавая полученный публичный токен доступа (далее AccessToken)
- Сервер утилизирует AccessToken, создаёт новый и возвращает
- App-js использует новый токен. Такой обмен одноразовыми токенами происходит каждый запрос. Для скорости можно
  использовать Redis.

#### Этот текст я писал для тестометрики:

1. получить публичный токен для пользователя
2. сгенерировать ссылку для пользователя

Теперь подробно:

1. Сначала делается скрытый запрос (backend, curl) и получается публичный токен:
   https://testonomica.com/partner/api/token/?token=JFeBtqLY3Tgw3uGG6b29hpdvfLlglGBE&user={ID_ПОЛЬЗОВАТЕЛЯ_ТЕСТОМЕТРИКИ}&service=proftest
   где {ID_ПОЛЬЗОВАТЕЛЯ_ТЕСТОМЕТРИКИ} - уникальный идентификатор пользователя в вашей системе. Дополнительно: чтобы
   протестировать интеграцию без оплаты нужно добавить в параметр &isTest=1, и тогда робокасса будет запущена в тестовом
   режиме, средства не списываются.

Ответом будет публичный токен в формате JSON:
{"token":"cf738dd7-a138-4fa6-b3fd-52eef8ae2a92"}

2. Нужно распарсить JSON и сгенерировать URL для пользователя:
   https://testonomica.com/partner/provide/?token={ПОЛУЧЕННЫЙ_ТОКЕН}
   Дальше этот URL навесить на кнопку "Пройти тест".

# Тестирование

## Интеграция с переходом на Тестономику (тест на стороне Тестономике) - так делает Тестометрика

[Локально (профгид)](http://pg/test/testonomica-direct/) \
[Удалённо (бамболо)](http://bamboloo.io/ru/test/proforientation/)

1. Удалить старые данные
2. Убедиться, что обновляя страницу токен в ссылке не меняется (значит он платёжный)
3. Пройти и оплатить (откроется тестовый режим)
4. Нажать кнопку "вернуться в магазин"
5. Убедиться, что загрузилась страница с тестом
6. Убедиться, что при обновлении страницы тест доступен
7. Убедиться, что тест начинается и проходится, результаты видны.
8. Убедиться, что обновление страницы не приводит к исчезновению результатов.

## Триальный тест на ПрофГиде без регистрации пользователя

[Триал тест на ПрофГиде](http://pg/test/proforientation-teen-trial.html)

1. Убедиться, что тест доступен
2. Убедиться, что тест проходится до конца

## Платный тест на ПрофГиде

[Платный тест на ПрофГиде](http://pg/my/products/)

1. Убедиться, что тесты доступны
2. Убедиться, что тесты проходятся.
3. Убедиться, что результаты доступны при обновлении страницы.

## Виджет

[Виджет напрямую](http://127.0.0.1:8000/tests/widget/1/?token=2ae25c25-1861-4f84-b243-ccfd9249fcdf)

1. в урле указать неоплаченный платёжный токен.
2. убедиться, что загружается страница
3. убедиться, что загружается платёжный виджет Cloudpayments.
4. провести тестовую оплату с данными 4242-4242-4242-4242, дата будущая, cvs любой.
5. выставить в БД статус "оплачено" (Cloudpayments шлёт уведомления на сервер).
6. убедитсья, что после нажатия кнопки "вернуться в магазин" открывается тест.
7. убедиться, что тест проходится и доступ есть ко всем страницам.
8. убедиться, что возникает ошибка если повторно обратиться к стратице с тем же платёжным токеном и попытаться пройти
   тест (так должно быть потому что иначе можно было бы передать урл и открыть тест).

## Виджет через Iframe (у партнёра)

[Виджет на ПрофГиде](http://pg/test/testonomica-widget/)

1. убедиться, что те же самые пункты работают правильно.
2. убедиться, что на всех шагах высота виджета корректная, всё умещается.

# Принципы

## Ошибки

Когда случается ошибка - не нужно пялиться в JS, посмотри логи сервера

# TODO

Проблемы безопасности (уровень доступа)
========

1. Партнёр генерирует 100000000000 ключей доступа по URL и просто их раздаёт.
2. Партнёр запрашивает результат платного теста без оплаты (можно привязать результат к чеку).

Решение проблемы кейса предоплаты:
----

1. Запрашивать чек (номер чека).
2. Запрашивать чек (номер чека).

Решение проблемы кейса постоплаты:
----

1. Генерация ключей не является проблемой, потому что доступ к прохождению бесплатный.
2. Запрашивать чек (номер чека).

Однако и чек и юзера и IP - всё это можно подделать, и я не узнаю правды. Есть только два решения:
- 1 юзер = 1 результат (или 1 чек = 1 результат)
- частая контролььная закупка (но токен можно получить, а юзать вообще на другом сайте).

Получается, что, нужно различать тесты предоплатные и постоплатные. Такая проверка сейчас в точности нигде не проходит.
Но в момент получения токена происходит выдача доступа если запрошен payment_type=external. Что нужно сделать:

- Явно указать payment_type: pre/post (вместо старых internal/external) в API получения токена.
- Для pre также передать check_id.
- Для post всё как обычно
- Записывать в access IP для постанализа

Предоплата на этапе получения токена:
----

1. provider + user + check
2. provider + user

Если с чеком:
регистрировать оплату с чеком и выдавать токен доступа.

Если без чека:
Как обычно - проверять provider + user и выдавать токен оплаты или доступа.

Постоплата на этапе получения токена:
----

1. provider + user:

-----

Но всё равно провайдер может передать чек оплаты для одного юзера, хотя по факту это может быть другой юзер. Это можно
контролировать только с помощью контрольных закупок. 2 раза в месяц. А раз мы делаем контрольные закупки, зачем городить
огород. Ну, хотя бы для статистики. Гарантированно каждого юзера проверить невозможно, но зато есть косвенные признаки,
которые полезны в сочетании:

- user ip.
- чек.
- контрольные закупки (без разглашения частоты). Если чек один и тот же, а IP всё время разный, то это подозрительно.

-----

- перевод сделать через доп.таблицу, (тут про это сказано: https://phrase.com/blog/posts/symfony-4-i18n/)
- покрыть тестами апи теста
- Использовать Db/Flusher::flush()
  таким образом будет возможна транзакция. это заставит многое переосмыслить и поменять. Ну, так и надо.
- Версионирование теста. Так, чтобы сохраненный результат не конфликтовал с версией xml теста или калькулятора Возможно,
  нужно указывать в результате версию пройденного теста, а в калькуляторе делать как минимум проверку и юзер-френдли
  исключения а-ля "Конфликт версий", или даже указывать диапазон допустимых версий или даже написать полифил.